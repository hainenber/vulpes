package io.hainenber.vulpes.vulnerability;

import io.hainenber.vulpes.VulnerabilityUpdater;
import io.hainenber.vulpes.entity.vulnerability.Vulnerability;
import io.hainenber.vulpes.opensearch.OpensearchClientFactory;
import io.hainenber.vulpes.testcontainers.OpensearchReusableContainer;
import org.eclipse.jgit.diff.DiffEntry;
import org.junit.ClassRule;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.opensearch.client.opensearch.OpenSearchClient;
import org.opensearch.client.opensearch.core.MgetRequest;
import org.opensearch.client.opensearch.core.mget.MultiGetResponseItem;
import org.opensearch.testcontainers.OpensearchContainer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mock;

@ActiveProfiles("test")
@SpringBootTest(classes = {VulnerabilityUpdater.class, OpensearchClientFactory.class})
public class VulnerabilityUpdaterTest {
    @Autowired
    private VulnerabilityUpdater vulnerabilityUpdater;

    @Autowired
    private OpensearchClientFactory opensearchClientFactory;

    @Value("${vulpes.opensearch.index}")
    private String indexName;

    @ClassRule
    public static OpensearchContainer<OpensearchReusableContainer> opensearchContainer = OpensearchReusableContainer.getInstance();

    @BeforeAll
    public static void setup() {
        opensearchContainer.start();
    }

    @DynamicPropertySource
    static void dynamicProperties(DynamicPropertyRegistry registry) {
        registry.add("vulpes.opensearch.url", opensearchContainer::getHttpHostAddress);
    }

    @Test
    public void givenOnlineOpenSearch_isOpensearchClusterOnline_thenReturnsTrue() throws Exception {
        assertTrue(vulnerabilityUpdater.isOpensearchClusterOnline());
    }

    @Test
    public void givenErroneousOpenSearch_isOpensearchClusterOnline_thenReturnsFalse() throws Exception {
        final OpensearchClientFactory mockedOpensearchClientFactory = mock(OpensearchClientFactory.class);
        Mockito.when(mockedOpensearchClientFactory.getOpensearchClient()).thenThrow(new Exception("Placeholder"));
        ReflectionTestUtils.setField(vulnerabilityUpdater, "opensearchClientFactory", mockedOpensearchClientFactory);
        assertFalse(vulnerabilityUpdater.isOpensearchClusterOnline());
    }

    @Test
    public void givenDiffEntries_updateFromGitDiffs_thenWorksAsExpected() throws Exception {
        opensearchClientFactory.createIndex(indexName);
        final OpenSearchClient openSearchClient = opensearchClientFactory.getOpensearchClient();

        final Path tempDir1 = Files.createTempDirectory("tmp");
        tempDir1.toFile().deleteOnExit();
        ReflectionTestUtils.setField(vulnerabilityUpdater, "advisoryDatabasePath", tempDir1.toString());

        final List<String> mockedVulns =  List.of("GHSA-2cvj-g5r5-jrrg.json", "GHSA-25qx-vfw2-fw8r.json");
        for (String vulnFilename : mockedVulns) {
            final Path vulnPath = Path.of(String.valueOf(tempDir1), vulnFilename);
            final Path vulnFile = Files.createFile(vulnPath);
            try (PrintWriter writer = new PrintWriter(Files.newBufferedWriter(vulnFile))) {
                writer.println(Files.readString(Path.of("src/test/resources/VulnerabilityFetcher", vulnFilename)));
            }
        }

        final List<DiffEntry> mockedDiffEntries = mockedVulns.stream().map(i -> {
            final DiffEntry mockedDiffEntry = mock(DiffEntry.class);
            Mockito.when(mockedDiffEntry.getNewPath()).thenReturn(i);
            return mockedDiffEntry;
        }).toList();

        assertDoesNotThrow(() -> vulnerabilityUpdater.updateFromGitDiffs(mockedDiffEntries));
        final List<String> mockedVulnNames = mockedVulns.stream().map(i -> i.replace(".json", "")).toList();
        final List<MultiGetResponseItem<Vulnerability>> actualUpdatedVulns = openSearchClient.mget(MgetRequest.of(r -> r
                .index(indexName)
                .ids(mockedVulnNames)
        ), Vulnerability.class).docs();
        assertTrue(actualUpdatedVulns.stream().filter(i -> i.result().found()).map(i -> i.result().id()).toList().containsAll(mockedVulnNames));
    }
}
