package io.hainenber.vulpes.vulnerability;

import static org.awaitility.Awaitility.await;
import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import io.hainenber.vulpes.VulnerabilityInitialIngester;
import io.hainenber.vulpes.entity.vulnerability.Vulnerability;
import io.hainenber.vulpes.opensearch.OpensearchClientFactory;
import io.hainenber.vulpes.repository.VulnerabilityRepository;
import io.hainenber.vulpes.testcontainers.OpensearchReusableContainer;
import org.junit.ClassRule;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.opensearch.client.opensearch.OpenSearchClient;
import org.opensearch.client.opensearch.core.MgetRequest;
import org.opensearch.client.opensearch.core.mget.MultiGetResponseItem;
import org.opensearch.testcontainers.OpensearchContainer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.FilterType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.nio.file.Path;
import java.util.List;
import java.util.stream.Stream;

@ActiveProfiles("test")
@DataJpaTest(includeFilters = {@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = {OpensearchClientFactory.class, VulnerabilityInitialIngester.class})})
@Testcontainers
public class VulnerabilityInitialIngesterTest {
    @Autowired
    private VulnerabilityRepository vulnerabilityRepository;

    @Autowired
    private OpensearchClientFactory opensearchClientFactory;

    @Autowired
    private VulnerabilityInitialIngester ingester;

    private static final String indexForMockedVulnIngestedFromScratch = "mocked-ghsa-vuln-load-from-scratch";
    private final List<String> expectedVulnsToBeIngested = List.of(
            "GHSA-fcpm-hchj-mh72", "GHSA-mwvh-p3hx-x4gg",
            "GHSA-cv55-v6rw-7r5v", "GHSA-pvxj-25m6-7vqr",
            "GHSA-fv9m-x5m2-3pqm", "GHSA-pwj6-h974-vc5v"
    );
    private final List<String> expectedVulnsNotToBeIngested = List.of(
            "GHSA-empty-string", "GHSA-without-json-filename"
    );

    @ClassRule
    public static OpensearchContainer<OpensearchReusableContainer> opensearchContainer = OpensearchReusableContainer.getInstance();

    @Container
    @ServiceConnection
    private static final PostgreSQLContainer<?> postgreSQLContainer = new PostgreSQLContainer<>("postgres:17.4-alpine");

    @BeforeAll
    public static void setUp() {
        opensearchContainer.start();
    }

    @DynamicPropertySource
    static void dynamicProperties(DynamicPropertyRegistry registry) {
        registry.add("vulpes.github.advisory-database.path", () -> Path.of("src/test/resources/VulnerabilityInitialIngester").toAbsolutePath().toString());
        registry.add("vulpes.opensearch.url", opensearchContainer::getHttpHostAddress);
        registry.add("vulpes.opensearch.index", () -> indexForMockedVulnIngestedFromScratch);
        registry.add("vulpes.load-data-from-scratch.opensearch", () -> true);
        registry.add("vulpes.load-data-from-scratch.postgresql", () -> true);
    }

    @Test
    public void whenToggledOpensearchStorage_populateVulnerabilitiesIntoStorage_thenSaveToOpensearch() throws Exception {
        await().until(ingester::isFullyIngestedToOpensearch);

        // Expect index created.
        final OpenSearchClient opensearchClient = opensearchClientFactory.getOpensearchClient();
        assertDoesNotThrow(() -> opensearchClient.indices().get(b -> b.index(indexForMockedVulnIngestedFromScratch)));
        // Expect vulns with proper data got ingested.
        final List<MultiGetResponseItem<Vulnerability>> actualIngestedVulns = opensearchClient.mget(MgetRequest.of(r -> r
                .index(indexForMockedVulnIngestedFromScratch)
                .ids(Stream.concat(expectedVulnsToBeIngested.stream(), expectedVulnsNotToBeIngested.stream()).toList())
        ), Vulnerability.class).docs();
        assertTrue(actualIngestedVulns.stream().filter(i -> i.result().found()).map(i -> i.result().id()).toList().containsAll(expectedVulnsToBeIngested));
        assertFalse(actualIngestedVulns.stream().filter(i -> i.result().found()).map(i -> i.result().id()).toList().containsAll(expectedVulnsNotToBeIngested));
    }

    @Test
    public void whenToggledPostgresqlStorage_populateVulnerabilitiesIntoStorage_thenSaveToPostgresql() {
        await().until(ingester::isFullyIngestedToPostgresql);

        assertEquals(vulnerabilityRepository.findAllById(expectedVulnsToBeIngested).stream().map(Vulnerability::getId).sorted().toList(), expectedVulnsToBeIngested.stream().sorted().toList());
    }
}
