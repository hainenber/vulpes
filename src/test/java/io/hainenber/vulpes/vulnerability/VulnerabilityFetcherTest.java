package io.hainenber.vulpes.vulnerability;

import io.hainenber.vulpes.VulnerabilityFetcher;
import io.hainenber.vulpes.VulnerabilityUpdater;
import io.hainenber.vulpes.entity.auditlog.AuditLog;
import io.hainenber.vulpes.repository.AuditLogRepository;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.diff.DiffEntry;
import org.eclipse.jgit.lib.Repository;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.Mockito.verify;

@ActiveProfiles("test")
@SpringBootTest(classes = VulnerabilityFetcher.class)
public class VulnerabilityFetcherTest {
    @MockitoBean
    private VulnerabilityUpdater mockedVulnerabilityUpdater;

    @MockitoBean
    private AuditLogRepository mockedAuditLogRepository;

    @Autowired
    private VulnerabilityFetcher vulnerabilityFetcher;

    @Test
    public void givenOfflineOpensearchCluster_fetchGithubAdvisoryDatabase_thenReturns() {
        assertNotNull(vulnerabilityFetcher);
        assertDoesNotThrow(() -> vulnerabilityFetcher.fetchGithubAdvisoryDatabase());
    }

    @Test
    public void givenBogusAdvisoryDatabasePathDir_fetchGithubAdvisoryDatabase_thenThrowsException() throws IOException {
        Mockito.when(mockedVulnerabilityUpdater.isOpensearchClusterOnline()).thenReturn(true);
        ReflectionTestUtils.setField(vulnerabilityFetcher, "advisoryDatabasePath", "does-not-exist" + UUID.randomUUID());

        // Non-existent directory
        final Exception exception1 = assertThrows(Exception.class, () -> vulnerabilityFetcher.fetchGithubAdvisoryDatabase());
        assertEquals("Advisory database path does not exist", exception1.getMessage());

        // Given path is not directory
        final Path tempFile = Files.createTempFile("test-", ".tmp");
        tempFile.toFile().deleteOnExit();
        ReflectionTestUtils.setField(vulnerabilityFetcher, "advisoryDatabasePath", tempFile.toString());
        final Exception exception2 = assertThrows(Exception.class, () -> vulnerabilityFetcher.fetchGithubAdvisoryDatabase());
        assertEquals("Advisory database path is not a directory", exception2.getMessage());

        // Empty directory
        final Path tempDir = Files.createTempDirectory("tmp");
        tempDir.toFile().deleteOnExit();
        ReflectionTestUtils.setField(vulnerabilityFetcher, "advisoryDatabasePath", tempDir.toString());
        final Exception exception3 = assertThrows(Exception.class, () -> vulnerabilityFetcher.fetchGithubAdvisoryDatabase());
        assertEquals("Advisory database path is a directory but it is empty", exception3.getMessage());

        // Not a version-controlled directory
        final Path tempDir1 = Files.createTempDirectory("tmp");
        tempDir1.toFile().deleteOnExit();
        final Path tempFile1 = Files.createFile(Path.of(String.valueOf(tempDir1), UUID.randomUUID().toString()));
        tempFile1.toFile().deleteOnExit();
        ReflectionTestUtils.setField(vulnerabilityFetcher, "advisoryDatabasePath", tempDir1.toString());
        final Exception exception4 = assertThrows(Exception.class, () -> vulnerabilityFetcher.fetchGithubAdvisoryDatabase());
        assertEquals("Advisory database directory path is not a Git repo", exception4.getMessage());
    }

    @Test
    public void givenCorrectPath_fetchGithubAdvisoryDatabase_thenWorksAsExpected() throws Exception {
        Mockito.when(mockedVulnerabilityUpdater.isOpensearchClusterOnline()).thenReturn(true);

        final Path mockedGitHubAdvisoryPath = Files.createTempDirectory(UUID.randomUUID().toString());
        mockedGitHubAdvisoryPath.toFile().deleteOnExit();
        ReflectionTestUtils.setField(vulnerabilityFetcher, "advisoryDatabasePath", mockedGitHubAdvisoryPath.toString());

        final String expectedCurrentCommit;
        final String expectedPreviousCommit;

        // Init a temp repo and make a initial commit
        final File dir = Files.createTempDirectory("mocked-ghsa-remote").toFile();
        dir.deleteOnExit();
        final Git git = Git.init().setDirectory(dir).setInitialBranch("main").call();
        try (Repository repo = git.getRepository()) {
            try (Git firstGit = new Git(repo)) {
                final File addedVulnerability1 = new File(repo.getDirectory().getParent(), "GHSA-001");
                addedVulnerability1.deleteOnExit();
                try (PrintWriter writer = new PrintWriter(addedVulnerability1)) {
                    writer.println("GHSA-001");
                }
                firstGit.add().addFilepattern(".").call();
                expectedPreviousCommit = firstGit.commit().setMessage("Added GHSA-001").setSign(false).call().getName();
            }
        }

        // Clone mocked GHSA from Git test-container.
        assertDoesNotThrow(() -> Git.cloneRepository()
                .setURI(dir.getAbsolutePath()).setDirectory(mockedGitHubAdvisoryPath.toFile()).call());

        // Commit a new vulnerability to remote
        try (Repository repo = git.getRepository()) {
            try (Git secondGit = new Git(repo)) {
                final File addedVulnerability2 = new File(repo.getDirectory().getParent(), "GHSA-002");
                addedVulnerability2.deleteOnExit();
                try (PrintWriter writer = new PrintWriter(addedVulnerability2)) {
                    writer.println("GHSA-002");
                }
                secondGit.add().addFilepattern(".").call();
                expectedCurrentCommit = secondGit.commit().setMessage("Added GHSA-002").setSign(false).call().getName();
            }
        }

        assertDoesNotThrow(() -> vulnerabilityFetcher.fetchGithubAdvisoryDatabase());
        verify(mockedVulnerabilityUpdater).updateFromGitDiffs(argThat(a -> a.stream().anyMatch(i -> i.getNewPath().contains("GHSA-002"))));

        final ArgumentCaptor<AuditLog> auditLogArgumentCaptor = ArgumentCaptor.forClass(AuditLog.class);
        verify(mockedAuditLogRepository).save(auditLogArgumentCaptor.capture());
        final AuditLog actualAuditLog = auditLogArgumentCaptor.getValue();

        assertTrue(actualAuditLog.getPreviousCommitId().contentEquals(expectedPreviousCommit));
        assertTrue(actualAuditLog.getCurrentCommitId().contentEquals(expectedCurrentCommit));
        assertTrue(actualAuditLog.getChanges().get(DiffEntry.ChangeType.ADD).contains("GHSA-002"));
    }
}
