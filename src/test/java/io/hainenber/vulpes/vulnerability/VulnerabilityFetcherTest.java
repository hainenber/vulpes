package io.hainenber.vulpes.vulnerability;

import io.hainenber.vulpes.VulnerabilityFetcher;
import io.hainenber.vulpes.VulnerabilityUpdater;
import io.hainenber.vulpes.repository.AuditLogRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mockito;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.util.ReflectionTestUtils;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.utility.DockerImageName;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;

@ActiveProfiles("test")
@SpringBootTest(classes = VulnerabilityFetcher.class)
public class VulnerabilityFetcherTest {
    @MockitoBean
    private VulnerabilityUpdater mockedVulnerabilityUpdater;

    @MockitoBean
    private AuditLogRepository mockedAuditLogRepository;

    @Autowired
    private VulnerabilityFetcher vulnerabilityFetcher;

    @TempDir
    private static File mockedGitHubAdvisoryPath;

    @Test
    public void givenOfflineOpensearchCluster_fetchGithubAdvisoryDatabase_thenReturns() {
        assertNotNull(vulnerabilityFetcher);
        assertDoesNotThrow(() -> vulnerabilityFetcher.fetchGithubAdvisoryDatabase());
    }

    @Test
    public void givenBogusAdvisoryDatabasePathDir_fetchGithubAdvisoryDatabase_thenThrowsException() throws IOException {
        Mockito.when(mockedVulnerabilityUpdater.isOpensearchClusterOnline()).thenReturn(true);
        ReflectionTestUtils.setField(vulnerabilityFetcher, "advisoryDatabasePath", "does-not-exist" + UUID.randomUUID());

        // Non-existent directory
        final Exception exception1 = assertThrows(Exception.class, () -> vulnerabilityFetcher.fetchGithubAdvisoryDatabase());
        assertEquals("Advisory database path does not exist", exception1.getMessage());

        // Given path is not directory
        final Path tempFile = Files.createTempFile("test-", ".tmp");
        tempFile.toFile().deleteOnExit();
        ReflectionTestUtils.setField(vulnerabilityFetcher, "advisoryDatabasePath", tempFile.toString());
        final Exception exception2 = assertThrows(Exception.class, () -> vulnerabilityFetcher.fetchGithubAdvisoryDatabase());
        assertEquals("Advisory database path is not a directory", exception2.getMessage());

        // Empty directory
        final Path tempDir = Files.createTempDirectory("tmp");
        tempDir.toFile().deleteOnExit();
        ReflectionTestUtils.setField(vulnerabilityFetcher, "advisoryDatabasePath", tempDir.toString());
        final Exception exception3 = assertThrows(Exception.class, () -> vulnerabilityFetcher.fetchGithubAdvisoryDatabase());
        assertEquals("Advisory database path is a directory but it is empty", exception3.getMessage());

        // Not a version-controlled directory
        final Path tempDir1 = Files.createTempDirectory("tmp");
        tempDir1.toFile().deleteOnExit();
        final Path tempFile1 = Files.createFile(Path.of(String.valueOf(tempDir1), UUID.randomUUID().toString()));
        tempFile1.toFile().deleteOnExit();
        ReflectionTestUtils.setField(vulnerabilityFetcher, "advisoryDatabasePath", tempDir1.toString());
        final Exception exception4 = assertThrows(Exception.class, () -> vulnerabilityFetcher.fetchGithubAdvisoryDatabase());
        assertEquals("Advisory database directory path is not a Git repo", exception4.getMessage());
    }

    @Test
    public void givenCorrectPath_fetchGithubAdvisoryDatabase_works_as_expected() {
        // TODO: implement
    }

    @Container
    @ServiceConnection
    public static final PostgreSQLContainer<?> postgresqlContainer = new PostgreSQLContainer<>(
            DockerImageName.parse("postgres:17-alpine"));

    @DynamicPropertySource
    static void dynamicProperties(DynamicPropertyRegistry registry) {
        registry.add("vulpes.github.advisory-database.path", mockedGitHubAdvisoryPath::getAbsolutePath);
    }
}
