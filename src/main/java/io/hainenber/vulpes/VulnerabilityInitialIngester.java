package io.hainenber.vulpes;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.hainenber.vulpes.entity.Vulnerability;
import org.opensearch.client.opensearch.OpenSearchClient;
import org.opensearch.client.opensearch._types.OpenSearchException;
import org.opensearch.client.opensearch.core.IndexRequest;
import org.opensearch.client.opensearch.indices.CreateIndexRequest;
import org.opensearch.client.opensearch.indices.GetIndexRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Objects;
import java.util.stream.Stream;

@ConditionalOnProperty(value = "vulpes.load-data-from-scratch", havingValue = "true")
@Component
public class VulnerabilityInitialIngester {
    private static final Logger log = LoggerFactory.getLogger(VulnerabilityInitialIngester.class);
    private static final ObjectMapper objectMapper = new ObjectMapper();

    @Value("${vulpes.github.advisory-database.path}")
    private String advisoryDatabasePath;

    @Value("${vulpes.opensearch.index}")
    private String indexName;

    @Value("${vulpes.opensearch.url}")
    private String opensearchClusterUrl;

    @Autowired
    private Environment environment;

    // Only load vulnerability data when whole application is ready.
    @EventListener(ApplicationReadyEvent.class)
    public void populateVulnerabilitiesIntoIndexIfEmpty() throws Exception {
        OpensearchClientFactory opensearchClientFactory = new OpensearchClientFactory(opensearchClusterUrl,
                environment.getProperty("OPENSEARCH_ADMIN_USERNAME"),
                environment.getProperty("OPENSEARCH_ADMIN_PASSWORD")
        );
        OpenSearchClient openSearchClient = opensearchClientFactory.getOpensearchClient();

        // Create index if not exist
        GetIndexRequest getIndexRequest = new GetIndexRequest.Builder().index(indexName).build();
        try {
            openSearchClient.indices().get(getIndexRequest);
        } catch (OpenSearchException getIndexException) {
            if (Objects.equals(getIndexException.error().type(), "index_not_found_exception")) {
                log.info("Index {} not yet created in OpenSearch cluster, creating one", indexName);
                CreateIndexRequest createIndexRequest = new CreateIndexRequest.Builder().index(indexName).build();
                openSearchClient.indices().create(createIndexRequest);
                log.info("Index {} created", indexName);
            } else {
                throw getIndexException;
            }
        }

        // Walk through vulnerability files and index them into the cluster.
        try (Stream<Path> vulnFileStream = Files.walk(Path.of(advisoryDatabasePath))) {
            vulnFileStream.forEach(p -> {
                String vulnerabilityFilename = p.getFileName().toString();
                if (vulnerabilityFilename.endsWith(".json")) {
                    String vulnerabilityString = "";
                    try {
                        vulnerabilityString = Files.readString(p);
                    } catch (IOException e) {
                        log.error("Failed to read vulnerability data from file {}: {}", vulnerabilityFilename, e.toString());
                    }
                    if (!vulnerabilityString.isBlank()) {
                        try {
                            Vulnerability vulnerability = objectMapper.readValue(vulnerabilityString, Vulnerability.class);
                            IndexRequest<Vulnerability> indexRequest = new IndexRequest.Builder<Vulnerability>()
                                    .index(indexName)
                                    .id(vulnerability.getId())
                                    .document(vulnerability)
                                    .build();
                            openSearchClient.index(indexRequest);
                            log.info("Successfully ingest vulnerability {} into OpenSearch cluster", p);
                        } catch (JsonProcessingException e) {
                            log.error("Failed to serialize vulnerability {} into Java class: {}", vulnerabilityFilename, e.toString());
                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }
                    }
                }
            });
        }
    }
}
