package io.hainenber.vulpes;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.hainenber.vulpes.entity.Vulnerability;
import org.apache.hc.client5.http.auth.AuthScope;
import org.apache.hc.client5.http.auth.UsernamePasswordCredentials;
import org.apache.hc.client5.http.impl.auth.BasicCredentialsProvider;
import org.apache.hc.client5.http.impl.nio.PoolingAsyncClientConnectionManager;
import org.apache.hc.client5.http.impl.nio.PoolingAsyncClientConnectionManagerBuilder;
import org.apache.hc.client5.http.ssl.ClientTlsStrategyBuilder;
import org.apache.hc.client5.http.ssl.NoopHostnameVerifier;
import org.apache.hc.client5.http.ssl.TrustAllStrategy;
import org.apache.hc.core5.http.HttpHost;
import org.apache.hc.core5.http.nio.ssl.TlsStrategy;
import org.apache.hc.core5.ssl.SSLContextBuilder;
import org.opensearch.client.opensearch.OpenSearchClient;
import org.opensearch.client.opensearch._types.OpenSearchException;
import org.opensearch.client.opensearch.core.IndexRequest;
import org.opensearch.client.opensearch.indices.CreateIndexRequest;
import org.opensearch.client.opensearch.indices.GetIndexRequest;
import org.opensearch.client.transport.OpenSearchTransport;
import org.opensearch.client.transport.httpclient5.ApacheHttpClient5TransportBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

import javax.net.ssl.SSLContext;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Objects;
import java.util.stream.Stream;

@ConditionalOnProperty(value = "load-data-from-scratch", havingValue = "true")
@Component
public class VulnerabilityInitialIngester {
    private static final Logger log = LoggerFactory.getLogger(VulnerabilityInitialIngester.class);
    private static final ObjectMapper objectMapper = new ObjectMapper();

    @Value("${vulpes.github.advisory-database.path}")
    private String advisoryDatabasePath;

    @Value("${vulpes.opensearch.url}")
    private String opensearchClusterUrl;

    @Autowired
    private Environment environment;

    public OpenSearchClient connect() throws Exception {
        // Configure credentials for authentication.
        final HttpHost opensearchHost = HttpHost.create(opensearchClusterUrl);
        String opensearchUsername = environment.getProperty("OPENSEARCH_ADMIN_USERNAME");
        String opensearchPassword = environment.getProperty("OPENSEARCH_ADMIN_PASSWORD");

        if (opensearchUsername == null || opensearchPassword == null)  {
           throw new Exception("OpenSearch cluster credentials are null");
        }

        // Remove single quotes intended for shell escape.
        opensearchUsername = opensearchUsername.replace("'", "");
        opensearchPassword = opensearchPassword.replace("'", "");

        BasicCredentialsProvider credentialsProvider = new BasicCredentialsProvider();
        credentialsProvider.setCredentials(new AuthScope(opensearchHost),
                new UsernamePasswordCredentials(opensearchUsername, opensearchPassword.toCharArray()));

        // Disable SSL verification.
        // TODO: remove this part for production deployment.
        final SSLContext bypassedSSLContext = SSLContextBuilder
                .create()
                .loadTrustMaterial(TrustAllStrategy.INSTANCE)
                .build();

        // Initialize transport and client with disabled SSL and hostname verification
        // TODO: remove this part for production deployment.
        final ApacheHttpClient5TransportBuilder builder = ApacheHttpClient5TransportBuilder.builder(opensearchHost);
        builder.setHttpClientConfigCallback(httpAsyncClientBuilder -> {
            final TlsStrategy tlsStrategy = ClientTlsStrategyBuilder.create()
                    .setSslContext(bypassedSSLContext)
                    .setHostnameVerifier(NoopHostnameVerifier.INSTANCE)
                    .build();
            final PoolingAsyncClientConnectionManager connectionManager = PoolingAsyncClientConnectionManagerBuilder
                    .create()
                    .setTlsStrategy(tlsStrategy)
                    .build();
            return httpAsyncClientBuilder
                    .setConnectionManager(connectionManager)
                    .setDefaultCredentialsProvider(credentialsProvider);
        });
        final OpenSearchTransport transport = builder.build();

        // Get overall cluster info as a quick health check
        try {
            OpenSearchClient openSearchClient = new OpenSearchClient(transport);
            openSearchClient.info();
            log.info("OpenSearch cluster connected successfully");
            return openSearchClient;
        } catch (Exception e) {
            log.error("Error initializing OpenSearch cluster: {1}", e);
            throw e;
        }
    }

    @EventListener(ApplicationReadyEvent.class) // Only load vulnerability data when whole application is ready.
    public void populateVulnerabilitiesIntoIndexIfEmpty() throws Exception {
        OpenSearchClient openSearchClient = connect();

        // Create index if not exist
        String indexName = "github-security-advisory-database";
        GetIndexRequest getIndexRequest = new GetIndexRequest.Builder().index(indexName).build();
        try {
            openSearchClient.indices().get(getIndexRequest);
        } catch (OpenSearchException getIndexException) {
            if (Objects.equals(getIndexException.error().type(), "index_not_found_exception")) {
                log.info("Index {} not yet created in OpenSearch cluster, creating one", indexName);
                CreateIndexRequest createIndexRequest = new CreateIndexRequest.Builder().index(indexName).build();
                openSearchClient.indices().create(createIndexRequest);
                log.info("Index {} created", indexName);
            } else {
                throw getIndexException;
            }
        }

        // Walk through vulnerability files and index them into the cluster.
            try (Stream<Path> vulnFileStream = Files.walk(Path.of(advisoryDatabasePath))) {
                vulnFileStream.forEach(p -> {
                    String vulnerabilityFilename = p.getFileName().toString();
                    if (vulnerabilityFilename.endsWith(".json")) {
                        String vulnerabilityString = "";
                        try {
                            vulnerabilityString = Files.readString(p);
                        } catch (IOException e) {
                            log.error("Failed to read vulnerability data from file {}: {}", vulnerabilityFilename, e.toString());
                        }
                        if (!vulnerabilityString.isBlank()) {
                            try {
                                Vulnerability vulnerability = objectMapper.readValue(vulnerabilityString, Vulnerability.class);
                                IndexRequest<Vulnerability> indexRequest = new IndexRequest.Builder<Vulnerability>()
                                        .index(indexName)
                                        .id(vulnerability.getId())
                                        .document(vulnerability)
                                        .build();
                                openSearchClient.index(indexRequest);
                                log.info("Successfully ingest vulnerability {} into OpenSearch cluster", p);
                            } catch (JsonProcessingException e) {
                                log.error("Failed to serialize vulnerability {} into Java class: {}", vulnerabilityFilename, e.toString());
                            } catch (IOException e) {
                                throw new RuntimeException(e);
                            }
                        }
                    }
                });
            }
        }
}
