package io.hainenber.vulpes;

import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.PullCommand;
import org.eclipse.jgit.api.PullResult;
import org.eclipse.jgit.diff.DiffEntry;
import org.eclipse.jgit.lib.ObjectId;
import org.eclipse.jgit.lib.ObjectReader;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.lib.StoredConfig;
import org.eclipse.jgit.treewalk.CanonicalTreeParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.io.File;
import java.util.List;
import java.util.Objects;

@Component
public class VulnerabilityFetcher {
    private static final Logger log = LoggerFactory.getLogger(VulnerabilityFetcher.class);
    private final VulnerabilityUpdater vulnerabilityUpdater;

    @Value("${vulpes.github.advisory-database.path}")
    private String advisoryDatabasePath;

    public VulnerabilityFetcher(VulnerabilityUpdater vulnerabilityUpdater) {
        this.vulnerabilityUpdater = vulnerabilityUpdater;
    }

    @Scheduled(fixedRateString = "${vulpes.github.advisory-database.fetch-interval}")
    public void fetchGithubAdvisoryDatabase() throws Exception {
        // Ensure advisory-database directory exists and non-empty
        final File advisoryDatabasePathDir = new File(advisoryDatabasePath);
        if (!advisoryDatabasePathDir.exists()) {
            throw new Exception("Advisory database path does not exist");
        }
        if (!advisoryDatabasePathDir.isDirectory()) {
            throw new Exception("Advisory database path is not a directory");
        }
        if (advisoryDatabasePathDir.length() == 0) {
            throw new Exception("Advisory database path is a directory but it is empty");
        }
        if (Objects.requireNonNull(advisoryDatabasePathDir.list(((dir, name) -> name.endsWith(".git")))).length == 0) {
            throw new Exception("Advisory database directory path is not a Git repo");
        }

        // Run "git pull origin main" command
        try (Git advisoryDatabaseGitRepo = Git.open(advisoryDatabasePathDir)) {
            final Repository advisoryDatabaseGitRepoObject = advisoryDatabaseGitRepo.getRepository();

            // Get current HEAD's Git reference before pulling.
            final ObjectId oldHead = advisoryDatabaseGitRepoObject.resolve("HEAD^{tree}");

            // Set jGit request buffer to a higher number since we're dealing with a huge repo.
            final StoredConfig storedConfig = advisoryDatabaseGitRepo.getRepository().getConfig();
            final int GIT_REQUEST_BUFFER = 10 * 10 * 1024;
            storedConfig.setInt("http", null, "postBuffer", GIT_REQUEST_BUFFER); // 10 MB
            storedConfig.save();

            final PullCommand pullCommand = advisoryDatabaseGitRepo.pull()
                    .setRemote("origin")
                    .setRemoteBranchName("main");
            final PullResult pullResult = pullCommand.call();
            if (pullResult.isSuccessful()) {
                log.info("Advisory database successfully updated with Git pull");
            } else {
                log.error("Advisory database failed to update with Git pull");
                log.error("Fetch result: {}, merge result: {}, rebase result: {}",
                        pullResult.getFetchResult().getMessages(),
                        pullResult.getMergeResult() != null ? pullResult.getMergeResult().getMergeStatus() : "null",
                        pullResult.getRebaseResult() != null ? pullResult.getRebaseResult().getStatus() : "null"
                );
            }

            if (pullResult.isSuccessful()) {
                // Get current HEAD's Git reference after pulling.
                final ObjectId currentHead = advisoryDatabaseGitRepoObject.resolve("HEAD^{tree}");

                // Get list of changed files after pulling.
                final ObjectReader reader = advisoryDatabaseGitRepoObject.newObjectReader();
                final CanonicalTreeParser oldTreeIter = new CanonicalTreeParser();
                oldTreeIter.reset(reader, oldHead);
                final CanonicalTreeParser newTreeIter = new CanonicalTreeParser();
                newTreeIter.reset(reader, currentHead);

                final List<DiffEntry> diffs = advisoryDatabaseGitRepo.diff()
                        .setNewTree(newTreeIter)
                        .setOldTree(oldTreeIter)
                        .call();
                if (!diffs.isEmpty()) {
                    vulnerabilityUpdater.updateFromGitDiffs(diffs);
                }
            }
        }
    }
}
