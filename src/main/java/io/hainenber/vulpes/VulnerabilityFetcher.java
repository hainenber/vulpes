package io.hainenber.vulpes;

import io.hainenber.vulpes.entity.auditlog.AuditLog;
import io.hainenber.vulpes.repository.AuditLogRepository;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.PullCommand;
import org.eclipse.jgit.api.PullResult;
import org.eclipse.jgit.diff.DiffEntry;
import org.eclipse.jgit.lib.Constants;
import org.eclipse.jgit.lib.ObjectId;
import org.eclipse.jgit.lib.ObjectReader;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.lib.StoredConfig;
import org.eclipse.jgit.treewalk.CanonicalTreeParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.TreeMap;

@Component
public class VulnerabilityFetcher {
    private static final Logger log = LoggerFactory.getLogger(VulnerabilityFetcher.class);
    private final VulnerabilityUpdater vulnerabilityUpdater;
    private final AuditLogRepository auditLogRepository;

    @Value("${vulpes.github.advisory-database.path}")
    private String advisoryDatabasePath;

    public VulnerabilityFetcher(VulnerabilityUpdater vulnerabilityUpdater, AuditLogRepository auditLogRepository) {
        this.vulnerabilityUpdater = vulnerabilityUpdater;
        this.auditLogRepository = auditLogRepository;
    }

    @Scheduled(fixedRateString = "${vulpes.github.advisory-database.fetch-interval}")
    public void fetchGithubAdvisoryDatabase() throws Exception {
        // Skip doing any Git fetch if the Opensearch cluster is not available.
        if (!vulnerabilityUpdater.isOpensearchClusterOnline()) {
            log.info("Opensearch cluster is not online. Skip current Git fetching for {}", advisoryDatabasePath);
            return;
        }

        // Ensure advisory-database directory exists and non-empty
        final File advisoryDatabasePathDir = new File(advisoryDatabasePath);
        if (!advisoryDatabasePathDir.exists()) {
            throw new Exception("Advisory database path does not exist");
        }
        if (!advisoryDatabasePathDir.isDirectory()) {
            throw new Exception("Advisory database path is not a directory");
        }
        if (advisoryDatabasePathDir.length() == 0) {
            throw new Exception("Advisory database path is a directory but it is empty");
        }
        if (Objects.requireNonNull(advisoryDatabasePathDir.list(((dir, name) -> name.endsWith(".git")))).length == 0) {
            throw new Exception("Advisory database directory path is not a Git repo");
        }

        // Run "git pull origin main" command
        try (Git advisoryDatabaseGitRepo = Git.open(advisoryDatabasePathDir)) {
            final Repository advisoryDatabaseGitRepoObject = advisoryDatabaseGitRepo.getRepository();

            // Get current HEAD's Git references (commit-id and tree-id) before pulling.
            final ObjectId oldHead = advisoryDatabaseGitRepoObject.resolve("HEAD^{tree}");
            final String previousCommitId = advisoryDatabaseGitRepoObject.resolve(Constants.HEAD).getName();

            // Set jGit request buffer to a higher number since we're dealing with a huge repo.
            final StoredConfig storedConfig = advisoryDatabaseGitRepo.getRepository().getConfig();
            final int GIT_REQUEST_BUFFER = 10 * 10 * 1024;
            storedConfig.setInt("http", null, "postBuffer", GIT_REQUEST_BUFFER); // 10 MB
            storedConfig.save();

            final PullCommand pullCommand = advisoryDatabaseGitRepo.pull()
                    .setRemote("origin")
                    .setRemoteBranchName("main");
            final PullResult pullResult = pullCommand.call();
            if (!pullResult.isSuccessful()) {
                log.error("Advisory database failed to update with Git pull");
                log.error("Fetch result: {}, merge result: {}, rebase result: {}",
                        pullResult.getFetchResult().getMessages(),
                        pullResult.getMergeResult() != null ? pullResult.getMergeResult().getMergeStatus() : "null",
                        pullResult.getRebaseResult() != null ? pullResult.getRebaseResult().getStatus() : "null"
                );
            }

            String currentCommitId = previousCommitId;

            if (pullResult.isSuccessful()) {
                // Get current HEAD's Git references (commit-id and tree-id) after pulling.
                final ObjectId currentHead = advisoryDatabaseGitRepoObject.resolve("HEAD^{tree}");
                currentCommitId =  advisoryDatabaseGitRepoObject.resolve(Constants.HEAD).getName();

                // Get list of changed files after pulling.
                // This can be done by comparing tree-id
                // Inspired by https://github.com/centic9/jgit-cookbook/blob/master/src/main/java/org/dstadler/jgit/porcelain/ShowChangedFilesBetweenCommits.java
                final ObjectReader reader = advisoryDatabaseGitRepoObject.newObjectReader();
                final CanonicalTreeParser oldTreeIter = new CanonicalTreeParser();
                oldTreeIter.reset(reader, oldHead);
                final CanonicalTreeParser newTreeIter = new CanonicalTreeParser();
                newTreeIter.reset(reader, currentHead);

                final List<DiffEntry> diffs = advisoryDatabaseGitRepo.diff()
                        .setNewTree(newTreeIter)
                        .setOldTree(oldTreeIter)
                        .call();

                final int diffCount = diffs.size();
                if (diffs.isEmpty()) {
                    log.info("Advisory database successfully updated with Git pull (no changes)");
                } else {
                    log.info("Advisory database successfully updated with Git pull ({} change{})",
                            diffCount,
                            diffCount > 1 ? "s" : ""
                    );
                }

                final Map<DiffEntry.ChangeType, List<String>> changes = new TreeMap<>();
                if (!diffs.isEmpty()) {
                    vulnerabilityUpdater.updateFromGitDiffs(diffs);
                    // Map changed vulnerabilities with its change type
                    // In case of deletion, usually after getting reviewed, we picked up the old CVE filename.
                    // In case GHSA vulnerability data got deleted.
                    for (DiffEntry diff: diffs) {
                        final String value = diff.getNewPath().equals("/dev/null")
                                ? diff.getOldPath()
                                : diff.getNewPath();
                        final DiffEntry.ChangeType key = diff.getChangeType();
                        if (changes.containsKey(key)) {
                            changes.get(key).add(value);
                        } else {
                            changes.put(key, new ArrayList<>(Collections.singletonList(value)));
                        }
                    }
                }

                // Save fetch data (change count, previous/current commit) as audit log.
                auditLogRepository.save(new AuditLog(previousCommitId, currentCommitId, changes));
                log.info("Successfully saved Git fetch data from {}", advisoryDatabaseGitRepoObject
                        .getConfig()
                        .getString("remote", "origin", "url")
                );
            }
        }
    }
}
